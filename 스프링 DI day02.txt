1.스프링 DI설정 및 사용 
 - 스프링 자체가 DI를 지원하는조립기 역할을 함 (조금더 범용적 )


->@Configuration으로 스프링 설정 클래스(객체관리 클래스)를 설정하고, @Bean을 이용해 각각 관리할 객체를 생성한다. 
 -@Bean 해당 메서드가 생성한 객체를 스프링 빈이라고 설정 
-AnnotationConfigApplicationContext 클래스를 이용해서 스프링 컨테이너를 생성
AnnotationContext ctx = new AnnotationConfigApplicationContext(AppCtx.class);
컨테이너를 생성하면 getBean() 메서드를 이용해서 사용할 객체를 구할 수 있다.
MemberRegisterService regSvc = ctx.getBean("memberRegSvc", MemberRegisterService.class);
(memberRegSvc빈객체 구하기)


*스프링 컨테이너는 기존 객체관리 클래스와 동일하게 객체를 생성하고 의존 객체를 주입한다. 기존 객체관리 클래스는 직접 객체를 생성하는 반면에 AnnotationConfigApplicationContext는 설정 파일 AppCtx 클래스로부터 생성할 객체의 주입 대상을 정한다.



2.DI 방식 

 1 : 생성자 방식
-생성자를 이용해서 의존 객체를 주입하기 위해 해당 설정을 담은 메서드를 호출

 2: DI: 세터 메서드 방식
-생성자 이외 세터 메서드를 통해 객체를 주입받기도 한다. 일반적인 세터(setter) 메서드는 자바빈 규칙에 따라 다음과 같이 작성
	1)메서드 이름이 set으로 시작한다.
	2)set 뒤에 첫 글자는 대문자로 시작한다.
	3)파라미터가 1개이다.
	4)리턴 타입이 void 이다.
-> 차이점
생성자 방식은 생성자의 매개변수의 개수가 많을 경우 각 인자가 어떤 의존 객체를 설정하는지 알아내려면 생성자의 코드를 확인해야 한다. 하지만 설정 메서드 방식은 메서드 이름만으로도 어떤 의존 객체를 설정하는지 쉽게 유추할 수 있다.
반면에 생성자 방식은 빈 객체를 생성하는 시점에 필요한 모든 의존 객체를 주입받기 때문에 객체를 사용할 때 완전한 상태로 사용할 수 있다. 하지만 세터 메서드 방식은 세터 메서드를 사용해서 필요한 의존 객체를 전달하지 않아도 빈 객체가 생성되기 때문에 객체를 사용하는 시점에 NullPointerException이 발생할 수 있다.


3.@Configuration 설정 클래스와 @Bean설정과 싱글톤 
-스프링 컨테이너는 @Bean이 붙은 메서드에 대해 한 개의 객체만 생성 - 여러번 호출해도 항상 같은 객체 생성 
-스프링은 설정 클래스를 그대로 사용하지 않는다. 대신 설정 클래스를 상속한 새로운 설정 클래스를 만들어서 사용한다. 스프링이 런타임에 생성한 설정 클래스는 다음과 유사한 방식으로 동작




4.두 개 이상의 설정 파일 사용하기

- 스프링을 이용해서 어플리케이션을 개발하다보면 수십 개에서 많게는 수백여 개 이상의 빈을 설정하게 된다. 설정하는 빈의 개수가 증가하면 한 개의 클래스 파일에 설정하는 것보다 영역별로 설정 파일을 나누면 관리하기 편해진다.

- 스프링은 한 개 이상의 설정 파일을 이용해서 컨테이너를 생성할 수 있다.
- @Autowired 애노테이션은 스프링의 자동주입 기능을 위한 것,  붙이면 해당 타입의 빈을 찾아서 필드에 할당,
- @Autowired 애노테이션을 이용해서 다른 설정 파일에 정의한 빈을 필드에 할당했다면 설정 메서드에서 이 필드를 사용해서 필요한 빈을 주입하면 된다.

@Autowired
private MemberDao memberDao;
	
@Autowired
private MemberPrinter memberPrinter;

@Bean
public MemberListPrinter listPrinter() {
	return new MemberListPrinter(memberDao, memberPrinter);
}


5.@Configuration 애노테이션, 빈, @Autowired 애노테이션
 -@Autowired 애노테이션은 스프링 빈에 의존하는 다른 빈을 자동으로 주입하고 싶을 때 사용
   *// 세터 메서드를 사용해서 의존 주입을 하지 않아도
	// 스프링 컨터네이가 @Autowired를 붙인 필드에 
	// 자동으로 해당 타입의 빈 객체를 주입

-@Configuration 애노테이션이 붙은 설정 클래스를 내부적으로 스프링 빈으로 등록
-@Autowired가 붙은 대상에 대해 알맞은 빈을 자동으로 주입
   -configuration
  -


-Import 애노테이션 사용
@Import 애노테이션을 사용하는 것이다. @Import 애노테이션은 함께 사용할 설정 클래스를 지정한다.
import spring.MemberDao;
-> @Import({ AppConf1.class, AppConf2.class }) 와 같이 배열을 이요ㅇ해서 두개이상의 설정 크래스도 지정할 수 있음 


6.getBean()메서드
* 설정클래스에서 만들어준 Bean메서드는 가변인자로 이루어진 설정클래스.class 객체 로  저장되어 있다가  getBean()메서드에 의해 호출됨 

  - 첫번째 인자:빈의 이름, 두번쨰 인자 : 빈의 타입 
 -getBean() 메서드를 호출할 때 존재하지 않는 빈 이름을 사용하거나 타입이 다르면 익셉션이 발생
	없는 빈 이름 사용시 - NoSuchBeanDefinitionException
	타입이 다른 경우 - BeanNotOfRequiredTypeException
	같은 타입의 빈 객체가 두개 이상 존재-NoUniqueBeanDefinitionException
-> 빈이름 없이 타입만으로도 빈을 구할 수 있음 


@Autowired 애노테이션을 이용한 의존 자동 주입
-필드에 @Autowired 애노테이션이 붙어 있으면 스프링이 해당 타입의 빈 객체를 찾아서 필드에 할당
-Autowired를 붙인후에는 설정클래스의 메서드에서  의존을 주입하는 코드를 삭제

-일치하는 빈이 없는 경우/일치하는 빈이 중복인 경우 :UnsatisfiedDependencyException이 발생

7.Qualifier 애노테이션을 이용한 의존 객체 선택
-@Qualifier 애노테이션을 사용하면 자동 주입 대상 빈을 한정
1) Bean 설정메서드에  @Qualifier(한정값) 
->이렇게 지정한 한정 값은 @Autowired 애노테이션에서 자동 주입할 빈을 한정할 떄 사용
2)  @Autowired 애노테이션에서 자동 주입할 빈을 한정할때 쓰임 
 @Autowired 
 @Qualifier(한정값) 
 메서드 ->  한정값에 해당하는 타입의 빈을 자동주입함 
3)빈 설정에 @Qualifier 애노테이션이 없으면 빈의 이름을 한정자로 지정

8.@Autowired 애노테이션의 필수 여부
- 자동주입 대상이 필수가 아닌경우, 예외발생보다는 null로 실행될수있도록  
1.@Autowired(required = false)로 지정
2.Optional 래퍼클래스 사용 :(스프링5부터 ) 
-자동 주입 대상 타입이 Optional인 경우, 일치하는 빈이 존재하지 않으면 값이 없는 Optional을 인자로 전달하고(익셉션이 발생하지 않는다). 일치하는 빈이 존재하면 해당 빈을 값으로 갖는 Optional을 인자로 전달한다. Optional을 사용하는 코드는 값 존재 여부에 따라 알맞게 의존 객체사용 
3.@Nullable 애노테이션
- 의존 주입 대상 매개변수에 붙여야함 
-스프링 컨테이너는 세터 메서드를 호출할 때 자동 주입할 빈이 존재하면 해당 빈을 인자로 전달하고, 존재하지 않으면 인자로 null을 전달
-@Autowired 애노테이션의 required 속성을 false로 할 때와 차이점은 @Nullable애노테이션을 사용하면 자동 주입할 빈이 존재하지 않아도 메서드가 호출된다는 점이다.
-@Autowired 애노테이션의 경우 required 속성이 false인데 대상 빈이 존재하지 않으면 세터 메서드를 호출하지 않는다.


9.컴포넌트스캔

1)@ComponentScan 대상 지정
-설정 클래스에 빈으로 등록하지 않아도 원하는 클래스를 빈으로 등록할 수 있으므로 컴포넌트 스캔 기능
-@Component 애노테이션으로 스캔 대상 지정
-@Component ("속성값") ->속성값이 있는경우 속성값이 빈이름이며, 속성값을 주지 않은 경우 클래스의 이름을 첫글자를 소문자로 바꾼 이름을 빈이름으로 사용 

2)@ComponentScan 애노테이션으로 스캔 설정
-캔해서 스프링 빈으로 등록하려면 설정 클래스에 @ComponentScan 애노테이션을 적용
-@ComponentScan(basePackages= {"spring"})
public class AppCtx {

3)컴포넌트 스캔 대상에서 제외하거나 포함하기
  
기본 스캔 대상
->@Aspect 애노테이션을 제외한 나머지 애노테이션은 실제로는 @Component 애노테이션에 대한 특수 애노테이션

  Configuration
 Service
 Controller 웹 MVC 관련
 Component
 Repository DB연동관련
 Aspect

4)컴포넌트 스캔에 따른 충동처리
 Filter 
-excludeFilters속성을 사용하면 스캔할 댸 특정 대상을 자동등록 대상에서 제외할 수 있음
-excludeFilters type속성값
 REGEX(정규표현식)
 ASPECTJ- AspectJ 패턴을 사용해서 대상을 지정 (aspectjweaver 모듈을 추가)
    Patterns 속성은 String[] 타입이므로 배열을 이용해서 패턴을 한 개 이상 지정할
 ANNOTATION  특정 애노테이션을 붙인 타입을 컴포넌트 대상에서 제외
 ASSIGNABLE_TYPE 특정 타입이나 그 하위 타입을 컴포넌트 스캔 대상에서 제외
 -설정할 필터가 두 개 이상이면 @ComponentScan의 excludeFilters 속성에 배열을 사용
	excludeFilters = {
		@Filter(type = FilterType.ANNOTATION, classes = ManualBean.class),
		@Filter(type = FilterType.REGEX, pattern = "spring2\\.*")
	})


-빈 이름 충돌:컴포넌트 스캔 과정에서 서로 다른 타입인데 같은 빈 이름을 사용하는 경우가 있다면 둘 중 하나에 명시적으로 빈 이름을 지정해서 이름 충돌을 피해야 한다.
-수동 등록한 빈과 충돌
-스캔할 때 사용하는 설정클래스의 빈 이름과 수동 등록한 빈 이름이 같은 경우 수동 등록한 빈이 우선한다.
-MemberDao를 관리하는 이름이 다른 두빈의 경우 두빈이 모두 존재하지만  자동주입시에는 @Qualifier 애노테이션을 사용해서 알맞은 빈을 선택



10.빈 라이프 사이클과 범위
객체 생성 -> 의존 설정 -> 초기화 -> 소멸

1) 컨테이너의 초기화
-AnnotationConfigApplicationContext의 생성자를 이용해서 컨텍스트 객체를 생성하는데 이 시점에 스프링 컨테이너를 초기화
-스프링 컨테이너는 설정 클래스에서 정보를 읽어와 알맞은 빈 객체를 생성하고 각 빈을 연결(의존 주입)하는 작업을 수행
- 초기화 완료시 컨테이너 사용가능 (getBean과 같은 메서드로 빈객체 구하기)

2)컨테이너의 종료 
-ctx.close() 메서드- bstractApplicationContext 클래스에 정의되어있음 

3)빈 객체의 초기화와 소멸 : 스프링 인터페이스

컨테이너 초기화 : 빈 객체의 생성, 의존 주입, 초기화
.InitializingBean 인터페이스 상속받아 초기화과정 구현가능
컨테이너 종료 : 빈 객체의 소멸
.DisposableBean 인터페이스 상속받아 소멸과정 구현가능 

-> 메인메서드와 상관없이 컨테이너 초기화소멸 과정에서  이루어짐 !!!

4)빈 객체의 초기화와 소멸 : 커스텀 메서드
- 위의 인터페이스대신 스프링 설정에서 직접 메서드를 지정 할 수 있음
-@Bean 태그에서 initMethod 속성과 destroyMethod 속성를 사용해서 초기화 메서드와 소멸 메서드의 이름을 지정 (매개변수는 지정 불가 )
  @Bean(initMethod="connect", destroyMethod="close")

5)빈 객체의 생성과 관리 범위
-스프링 컨테이너는 빈 객체를 한 개만 생성 (싱글톤)- 기본
-빈의 범위를 프로토타입으로 지정하면 빈 객체를 구할 때 마다 매번 새로운 객체를 생성
@Bean
@Scope("prototype")
-프로토타입 범위를 갖는 빈은 완전한 라이프사이클을 따르지 않는다는 점에 주의
-프로토타입의 빈 객체를 생성하고 프로퍼티를 설정하고 초기화 작업까지는 수행하지만 컨테이너를 종료한다고 해서 생성자 프로토타입 빈 객체의 소멸 메서드를 실행하지는 않는다.
-프로토타입 범위의 빈을 사용할 때에는 빈 객체의 소명 처리를 코드에서 직접 해야 한다.


